mu.modterr <- link(mod.terr, data=list(area=terr.seq))
mu.modterr.mean <- apply(mu.modterr, 2, mean)
mu.modterr.PI <- apply(mu.modterr, 2, PI, .89)
plot(weight~area, foxes, col='red')
lines(terr.seq, mu.modterr.mean, col='black')
shade(mu.modterr.PI, terr.seq)
plot(precis(mod.terr))
abline(v=0, col="gray", lty=3, lwd=3)
# Let's check out group size now, in the exact same way as above...
mod.group <- map(
alist(
weight ~ dnorm(mu , sigma),
mu <- intercept + b_group*groupsize,
intercept ~ dnorm(0,10),
b_group ~ dnorm(0,10),
sigma ~ dunif(0,5)
),
data=foxes
)
precis(mod.group)
group.seq <- seq(1,9,0.1)
mu.modgroup <- link(mod.group, data=list(groupsize=group.seq))
mu.modgroup.mean <- apply(mu.modgroup, 2, mean)
mu.modgroup.PI <- apply(mu.modgroup, 2, PI, .89)
plot(weight~groupsize, foxes, col='red')
lines(group.seq, mu.modgroup.mean, col='black')
shade(mu.modgroup.PI, group.seq)
plot(precis(mod.group))
abline(v=0, col="gray", lty=3, lwd=3)
par(mfrow=c(1,2))
plot(precis(mod.terr))
abline(v=0, col="gray", lty=3, lwd=3)
plot(precis(mod.group))
abline(v=0, col="gray", lty=3, lwd=3)
dev.off()
par(mfrow=c(1,2))
plot(precis(mod.terr))
abline(v=0, col="gray", lty=3, lwd=3)
plot(precis(mod.group))
abline(v=0, col="gray", lty=3, lwd=3)
########################## 5H2 ################################
# Alright, now for the good stuff!
mod.both <- map(alist(
weight ~ dnorm(mu , sigma),
mu <- intercept + b_group*groupsize + b_terr*area,
intercept ~ dnorm(0,10),
b_group ~ dnorm(0,10),
b_terr ~ dnorm(0,10),
sigma ~ dunif(0,5)
),
data=foxes
)
precis(mod.both)
## Okay, now we'll plot territory size while keeping group size constant
mod.both.terr <- link(mod.both, data=data.frame(groupsize=mean(foxes$groupsize), area=terr.seq))
mod.both.terr.mean <- apply(mod.both.terr, 2, mean)
mod.both.terr.PI <- apply(mod.both.terr, 2, PI, .89)
plot(weight~area, foxes, col='red')
lines(terr.seq, mod.both.terr.mean, col='blue')
dev.off()
########################## 5H2 ################################
# Alright, now for the good stuff!
mod.both <- map(alist(
weight ~ dnorm(mu , sigma),
mu <- intercept + b_group*groupsize + b_terr*area,
intercept ~ dnorm(0,10),
b_group ~ dnorm(0,10),
b_terr ~ dnorm(0,10),
sigma ~ dunif(0,5)
),
data=foxes
)
precis(mod.both)
## Okay, now we'll plot territory size while keeping group size constant
mod.both.terr <- link(mod.both, data=data.frame(groupsize=mean(foxes$groupsize), area=terr.seq))
mod.both.terr.mean <- apply(mod.both.terr, 2, mean)
mod.both.terr.PI <- apply(mod.both.terr, 2, PI, .89)
plot(weight~area, foxes, col='red')
lines(terr.seq, mod.both.terr.mean, col='blue')
shade(mod.both.terr.PI, terr.seq, col = col.alpha("blue",0.5))
# Now we'll plot groupsize while keeping territory size constant
mod.both.group <- link(mod.both, data=data.frame(area=mean(foxes$area), groupsize=group.seq))
mod.both.group.mean <- apply(mod.both.group, 2, mean)
mod.both.group.PI <- apply(mod.both.group, 2, PI, .89)
plot(weight~groupsize, foxes, col='red')
lines(group.seq, mod.both.group.mean, col='blue')
shade(mod.both.group.PI, group.seq, col = col.alpha("blue",0.5))
par(mfrow=c(1,3))
plot(precis(mod.both))
abline(v=0, col="gray", lty=3, lwd=3)
plot(weight~area, foxes, col='red')
lines(terr.seq, mod.both.terr.mean, col='blue')
shade(mod.both.terr.PI, terr.seq, col = col.alpha("blue",0.5))
plot(weight~groupsize, foxes, col='red')
lines(group.seq, mod.both.group.mean, col='blue')
shade(mod.both.group.PI, group.seq, col = col.alpha("blue",0.5))
## Answering Questions from Chapter 5 & 6 in Rethinking
# Questions assigned: 5H2-3 and 6M5-6
# housekeeping
rm(list=ls())
options(stringsAsFactors = FALSE)
dev.off()
## Load libraries
library(ggplot2)
library(rethinking)
# Load the data
data(foxes)
foxes <- foxes
# Start with 5H1 since it leads into 5H2 and 5H3
### Linear model with territory size
mod.terr <- map(
alist(
weight ~ dnorm(mu , sigma),
mu <- intercept + b_terr*area,
intercept ~ dnorm(0,10),
b_terr ~ dnorm(0,10),
sigma ~ dunif(0,5)
),
data=foxes
)
precis(mod.terr)
terr.seq <- seq(1,6,0.1)
mu.modterr <- link(mod.terr, data=list(area=terr.seq))
mu.modterr.mean <- apply(mu.modterr, 2, mean)
mu.modterr.PI <- apply(mu.modterr, 2, PI, .89)
plot(weight~area, foxes, col='red')
lines(terr.seq, mu.modterr.mean, col='black')
shade(mu.modterr.PI, terr.seq)
plot(precis(mod.terr))
abline(v=0, col="gray", lty=3, lwd=3)
### SO AREA IS NOT VERY IMPORTANT IN PREDICTING FOX WEIGHT!
# Let's check out group size now, in the exact same way as above...
mod.group <- map(
alist(
weight ~ dnorm(mu , sigma),
mu <- intercept + b_group*groupsize,
intercept ~ dnorm(0,10),
b_group ~ dnorm(0,10),
sigma ~ dunif(0,5)
),
data=foxes
)
precis(mod.group)
group.seq <- seq(1,9,0.1)
mu.modgroup <- link(mod.group, data=list(groupsize=group.seq))
mu.modgroup.mean <- apply(mu.modgroup, 2, mean)
mu.modgroup.PI <- apply(mu.modgroup, 2, PI, .89)
plot(weight~groupsize, foxes, col='red')
lines(group.seq, mu.modgroup.mean, col='black')
shade(mu.modgroup.PI, group.seq)
plot(precis(mod.group))
abline(v=0, col="gray", lty=3, lwd=3)
### AND NEITHER IS GROUP SIZE BUT SLIGHTLY MORE THAN TERRITORY SIZE... INTERESTING!
par(mfrow=c(1,2))
plot(precis(mod.terr))
abline(v=0, col="gray", lty=3, lwd=3)
plot(precis(mod.group))
abline(v=0, col="gray", lty=3, lwd=3)
dev.off()
########################## 5H2 ################################
# Alright, now for the good stuff!
mod.both <- map(alist(
weight ~ dnorm(mu , sigma),
mu <- intercept + b_group*groupsize + b_terr*area,
intercept ~ dnorm(0,10),
b_group ~ dnorm(0,10),
b_terr ~ dnorm(0,10),
sigma ~ dunif(0,5)
),
data=foxes
)
precis(mod.both)
########################## 5H2 ################################
# Alright, now for the good stuff!
mod.both <- map(alist(
weight ~ dnorm(mu , sigma),
mu = intercept + b_group*groupsize + b_terr*area,
intercept ~ dnorm(0,10),
b_group ~ dnorm(0,10),
b_terr ~ dnorm(0,10),
sigma ~ dunif(0,5)
),
data=foxes
)
########################## 5H2 ################################
# Alright, now for the good stuff!
mod.both <- map(alist(
weight ~ dnorm(mu , sigma),
mu <- intercept + b_group*groupsize + b_terr*area,
intercept ~ dnorm(0,10),
b_group ~ dnorm(0,10),
b_terr ~ dnorm(0,10),
sigma ~ dunif(0,5)
),
data=foxes
)
precis(mod.both)
## Okay, now we'll plot territory size while keeping group size constant
mod.both.terr <- link(mod.both, data=data.frame(groupsize=mean(foxes$groupsize), area=terr.seq))
mod.both.terr.mean <- apply(mod.both.terr, 2, mean)
mod.both.terr.PI <- apply(mod.both.terr, 2, PI, .89)
plot(weight~area, foxes, col='red')
lines(terr.seq, mod.both.terr.mean, col='blue')
shade(mod.both.terr.PI, terr.seq, col = col.alpha("blue",0.5))
# Now we'll plot groupsize while keeping territory size constant
mod.both.group <- link(mod.both, data=data.frame(area=mean(foxes$area), groupsize=group.seq))
mod.both.group.mean <- apply(mod.both.group, 2, mean)
mod.both.group.PI <- apply(mod.both.group, 2, PI, .89)
plot(weight~groupsize, foxes, col='red')
lines(group.seq, mod.both.group.mean, col='blue')
shade(mod.both.group.PI, group.seq, col = col.alpha("blue",0.5))
par(mfrow=c(1,3))
plot(precis(mod.both))
abline(v=0, col="gray", lty=3, lwd=3)
plot(weight~area, foxes, col='red')
lines(terr.seq, mod.both.terr.mean, col='blue')
shade(mod.both.terr.PI, terr.seq, col = col.alpha("blue",0.5))
plot(weight~groupsize, foxes, col='red')
lines(group.seq, mod.both.group.mean, col='blue')
shade(mod.both.group.PI, group.seq, col = col.alpha("blue",0.5))
dev.off()
########################## 5H3 ################################
# So we start with body size as an additive function of avgfood and groupsize, per Richard's request
mod.foodgroup <- map(alist(
weight ~ dnorm(mu , sigma),
mu <- intercept + b_group*groupsize + b_food*avgfood,
intercept ~ dnorm(0,10),
b_group ~ dnorm(0,10),
b_food ~ dnorm(0,10),
sigma ~ dunif(0,5)
),
data=foxes
)
precis(mod.foodgroup)
## And now all three!
mod.all <- map(alist(
weight ~ dnorm(mu , sigma),
mu <- intercept + b_group*groupsize + b_terr*area + b_food*avgfood,
intercept ~ dnorm(0,10),
b_group ~ dnorm(0,10),
b_terr ~ dnorm(0,10),
b_food ~ dnorm(0,10),
sigma ~ dunif(0,5)
),
data=foxes
)
precis(mod.all)
mod.all.group <- link(mod.all, data=data.frame(area=mean(foxes$area), avgfood=mean(foxes$avgfood), groupsize=group.seq))
mod.all.group.mean <- apply(mod.all.group, 2, mean)
mod.all.group.PI <- apply(mod.all.group, 2, PI, .89)
food.seq <- seq(0,1.5,0.1)
mod.all.food <- link(mod.all, data=data.frame(area=mean(foxes$area), groupsize=mean(foxes$groupsize), avgfood=food.seq))
mod.all.food.mean <- apply(mod.all.food, 2, mean)
mod.all.food.PI <- apply(mod.all.food, 2, PI, .89)
mod.all.area <- link(mod.all, data=data.frame(avgfood=mean(foxes$avgfood), groupsize=mean(foxes$groupsize), area=terr.seq))
mod.all.area.mean <- apply(mod.all.area, 2, mean)
mod.all.area.PI <- apply(mod.all.area, 2, PI, .89)
par(mfrow=c(2,3))
plot.new()
plot(precis(mod.all))
abline(v=0, col="gray", lty=2, lwd=3)
plot.new()
plot(weight~groupsize, foxes, col='red')
lines(group.seq, mod.all.group.mean, col='blue')
shade(mod.all.group.PI, group.seq, col = col.alpha("blue",0.5))
plot(weight~avgfood, foxes, col='red')
lines(food.seq, mod.all.food.mean, col='blue')
shade(mod.all.food.PI, food.seq, col = col.alpha("blue",0.5))
plot(weight~area, foxes, col='red')
lines(terr.seq, mod.all.area.mean, col='blue')
shade(mod.all.area.PI, terr.seq, col = col.alpha("blue",0.5))
plot(groupsize ~ area, data=foxes)
dev.off()
plot(groupsize ~ area, data=foxes)
## and then we look at average food variable
par(mfrow=c(1, 3))
plot(groupsize ~ area, data=foxes)
plot(groupsize ~ avgfood, data=foxes)
plot(avgfood ~ area, data=foxes)
mod.foodarea <- map(alist(
weight ~ dnorm(mu , sigma),
mu <- intercept + b_terr*area + b_food*avgfood,
intercept ~ dnorm(0,10),
b_terr ~ dnorm(0,10),
b_food ~ dnorm(0,10),
sigma ~ dunif(0,5)
),
data=foxes
)
precis(mod.foodarea)
########################## 5H3 ################################
# So we start with body size as an additive function of avgfood and groupsize, per Richard's request
mod.foodgroup <- map(alist(
weight ~ dnorm(mu , sigma),
mu <- intercept + b_group*groupsize + b_food*avgfood,
intercept ~ dnorm(0,10),
b_group ~ dnorm(0,10),
b_food ~ dnorm(0,10),
sigma ~ dunif(0,5)
),
data=foxes
)
precis(mod.foodgroup)
df <- read.csv("~/Documents/git/ospree/analyses/output/ospree_clean.csv")
sort(unique(df$respvar))
budset <- df[(df$respvar=="daystobudset"),]
budset <- df[(df$respvar=="percentbudburst_dormancy"),]
View(budset)
## Load library
library(MASS)
library(rethinking)
## Load data
data(eagles)
dat <- eagles
## Convert letters to numbers
dat$P <- ifelse(dat$P == "S", 0, 1)
dat$A <- ifelse(dat$A == "I", 0, 1)
dat$V <- ifelse(dat$V == "S", 0, 1)
## Create proportion column
dat$prop <- dat$y / dat$n
## Inspect
head(dat)
## Model 1
m.eagles <- map2stan(
alist(
y ~ dbinom(n, p),
logit(p)  <-  a + bp * P + bv * V + ba * A,
a ~ dnorm(0, 10),
bp ~ dnorm(0, 5),
bv ~ dnorm(0, 5),
ba ~ dnorm(0, 5)
),
data = dat, iter = 4000, chains = 4)
## Obtain estimates
precis(m.eagles)
## Compare to previous model
compare(m.eagles, m2.eagles)
## Plot model predictions
dat.pred <- expand.grid(P = c(0, 1), A = c(0, 1), V = c(0, 1))
link.m.eagles <- link(m.eagles, data = dat.pred)
pred.p <- apply(link.m.eagles, 2, mean)
pred.p.HPDI <- apply(link.m.eagles, 2, HPDI, prob = .89)
par(mfrow = c(1, 2)) # will be adding another plot later
plot(0, 0, type = "n", xlab = "Pirate/Adult/Victim", ylab = "Success probability",
ylim = c(0, 1), xlim = c(1, 8), xaxt = "n", main = "m.eagles")
axis(1, at = 1:8, labels = c("0/0/0", "1/0/0", "0/1/0", "1/1/0", "0/0/1", "1/0/1", "0/1/1", "1/1/1"))
p <- by(dat$prop,
list(dat$P, dat$A, dat$V), mean)
## Plot model predictions
dat.pred <- expand.grid(P = c(0, 1), A = c(0, 1), V = c(0, 1))
link.m.eagles <- link(m.eagles, data = dat.pred)
pred.p <- apply(link.m.eagles, 2, mean)
pred.p.HPDI <- apply(link.m.eagles, 2, HPDI, prob = .89)
par(mfrow = c(1, 2)) # will be adding another plot later
plot(0, 0, type = "n", xlab = "Pirate/Adult/Victim", ylab = "Success probability",
ylim = c(0, 1), xlim = c(1, 8), xaxt = "n", main = "m.eagles")
axis(1, at = 1:8, labels = c("0/0/0", "1/0/0", "0/1/0", "1/1/0", "0/0/1", "1/0/1", "0/1/1", "1/1/1"))
p <- by(dat$prop,
list(dat$P, dat$A, dat$V), mean)
for(i in 1:nrow(dat)){
points(p[i] ~ c(i - .05), pch = 16, col = "black", cex = 1.2)
points(pred.p[i] ~ c(i + .05), pch = 16, col = "blue", cex = 1.2)
lines(x = rep(i + .05, 2), y = pred.p.HPDI[, i], col = rgb(0, 0, 1, alpha = .5), lwd = 2)
}
legend("topright", c("Observed", "Predicted"), col = c("blue", "black"), pch = 16)
quartz()
## Plot model predictions
dat.pred <- expand.grid(P = c(0, 1), A = c(0, 1), V = c(0, 1))
link.m.eagles <- link(m.eagles, data = dat.pred)
pred.p <- apply(link.m.eagles, 2, mean)
pred.p.HPDI <- apply(link.m.eagles, 2, HPDI, prob = .89)
par(mfrow = c(1, 2)) # will be adding another plot later
plot(0, 0, type = "n", xlab = "Pirate/Adult/Victim", ylab = "Success probability",
ylim = c(0, 1), xlim = c(1, 8), xaxt = "n", main = "m.eagles")
axis(1, at = 1:8, labels = c("0/0/0", "1/0/0", "0/1/0", "1/1/0", "0/0/1", "1/0/1", "0/1/1", "1/1/1"))
p <- by(dat$prop,
list(dat$P, dat$A, dat$V), mean)
for(i in 1:nrow(dat)){
points(p[i] ~ c(i - .05), pch = 16, col = "black", cex = 1.2)
points(pred.p[i] ~ c(i + .05), pch = 16, col = "blue", cex = 1.2)
lines(x = rep(i + .05, 2), y = pred.p.HPDI[, i], col = rgb(0, 0, 1, alpha = .5), lwd = 2)
}
legend("topright", c("Observed", "Predicted"), col = c("blue", "black"), pch = 16)
961+1315+1282+1653
1653/5211
3800*3
install.packages("swirl")
library(swirl)
18*40*52
170*5*52
library(brms)
## Set Working Directory
setwd("~/Documents/git/regionalrisk")
load("long_full.Rdata")
load("dvrlong_full.Rdata")
load("fivelong_full.Rdata")
load("longtemps_full.Rdata")
fs <- read.csv("analyses/output/fs_newspace_long.csv", header=TRUE)
fsdvr <- read.csv("analyses/output/fs_newspace_dvrlong.csv", header=TRUE)
fsfive <- read.csv("analyses/output/fs_newspace_fivelong.csv", header=TRUE)
fstemps <- read.csv("analyses/output/fs_newspace_longtemps.csv", header=TRUE)
numyrs<-length(unique(fs$year))
numsites<-length(unique(fs$lat.long))
### So if we multiply by the sd used above to change intervals and use the Divide by 4 rule:
mat<-round((mean(fixef(long.full, pars="mat.z", summary=FALSE))/4)/(sd(fs$mst)*2)*100*2, digits=2) ## -7.638351 (vs -3.331)
nao<-round((mean(fixef(long.full, pars="nao.z", summary=FALSE))/4)/(sd(fs$nao)*2)*100*0.3, digits=2) ## 1.915104 (vs 1.54)
dist<-round((mean(fixef(long.full, pars="dist.z", summary=FALSE))/4)/(sd(fs$distkm)*2)*100*150, digits=2) ## 5.320474 (vs 4.83)
elev<-round((mean(fixef(long.full, pars="elev.z", summary=FALSE))/4)/(sd(fs$elev)*2)*100*200, digits=2)## 2.235522 (vs 1.89)
matz<-round((mean(fixef(long.full, pars="mat.z", summary=FALSE))), digits=2)
naoz<-round((mean(fixef(long.full, pars="nao.z", summary=FALSE))), digits=2)
distz<-round((mean(fixef(long.full, pars="dist.z", summary=FALSE))), digits=2)
elevz<-round((mean(fixef(long.full, pars="elev.z", summary=FALSE))), digits=2)
aescc<-round((mean(fixef(long.full, pars="cc.z", summary=FALSE))/4)/(sd(fs$cc)*2)*100,digits=2)
aescc
alncc<-round(((mean(fixef(long.full, pars="cc.z", summary=FALSE))+ mean(fixef(long.full, pars="speciesALNGLU", summary=FALSE)))/4)/(sd(fs$cc)*2)*100, digits=2)
alncc
betcc<-roundround(((mean(fixef(long.full, pars="cc.z", summary=FALSE))+ mean(fixef(long.full, pars="speciesBETPEN", summary=FALSE)))/4)/(sd(fs$cc)*2)*100, digits=2)
betcc<-round(((mean(fixef(long.full, pars="cc.z", summary=FALSE))+ mean(fixef(long.full, pars="speciesBETPEN", summary=FALSE)))/4)/(sd(fs$cc)*2)*100, digits=2)
betcc
fagcc<-round(((mean(fixef(long.full, pars="cc.z", summary=FALSE))+ mean(fixef(long.full, pars="speciesFAGSYL", summary=FALSE)))/4)/(sd(fs$cc)*2)*100, digits=2)
fagcc
fracc<-round(((mean(fixef(long.full, pars="cc.z", summary=FALSE))+ mean(fixef(long.full, pars="speciesFRAEXC", summary=FALSE)))/4)/(sd(fs$cc)*2)*100, digits=2)
fracc
quecc<-round(((mean(fixef(long.full, pars="cc.z", summary=FALSE))+ mean(fixef(long.full, pars="speciesQUEROB", summary=FALSE)))/4)/(sd(fs$cc)*2)*100, digits=2)
quecc
allcc <- (aescc+alncc+betcc+fagcc+fracc+quecc)/6
allcc
mean(fixef(long.full, pars="cc.z", summary=FALSE))+ mean(fixef(long.full, pars="speciesQUEROB", summary=FALSE))
sd(fs$cc)*2)
sd(fs$cc)*2
aescc<-round((mean(fixef(long.full, pars="cc.z", summary=FALSE))/4)/(sd(fs$cc)*2)*100,digits=2)
alncc<-round(((mean(fixef(long.full, pars="cc.z", summary=FALSE))+ mean(fixef(long.full, pars="cc.z:speciesALNGLU", summary=FALSE)))/4)/(sd(fs$cc)*2)*100, digits=2)
betcc<-round(((mean(fixef(long.full, pars="cc.z", summary=FALSE))+ mean(fixef(long.full, pars="cc.z:speciesBETPEN", summary=FALSE)))/4)/(sd(fs$cc)*2)*100, digits=2)
fagcc<-round(((mean(fixef(long.full, pars="cc.z", summary=FALSE))+ mean(fixef(long.full, pars="cc.z:speciesFAGSYL", summary=FALSE)))/4)/(sd(fs$cc)*2)*100, digits=2)
fracc<-round(((mean(fixef(long.full, pars="cc.z", summary=FALSE))+ mean(fixef(long.full, pars="cc.z:speciesFRAEXC", summary=FALSE)))/4)/(sd(fs$cc)*2)*100, digits=2)
quecc<-round(((mean(fixef(long.full, pars="cc.z", summary=FALSE))+ mean(fixef(long.full, pars="cc.z:speciesQUEROB", summary=FALSE)))/4)/(sd(fs$cc)*2)*100, digits=2)
allcc <- (aescc+alncc+betcc+fagcc+fracc+quecc)/6
allcc
load("bbmod.Rdata")
simpbb <- as.data.frame(fixef(bb.mod, pars=c("cc", "cc:speciesALNGLU", "cc:speciesBETPEN", "cc:speciesFAGSYL", "cc:speciesFRAEXC", "cc:speciesQUEROB")))
simpbb$parameter <- rownames(simpbb)
simpbb$Estimate <- ifelse(simpbb$parameter=="cc", simpbb$Estimate, simpbb$Estimate + simpbb$Estimate[simpbb$parameter=="cc"])
simpbb <- round(mean(simpbb$Estimate), digits=2)
load("tminmod_long.Rdata")
simptmin <- as.data.frame(fixef(tminlong.mod, pars=c("cc", "cc:speciesALNGLU", "cc:speciesBETPEN", "cc:speciesFAGSYL", "cc:speciesFRAEXC", "cc:speciesQUEROB")))
simptmin$parameter <- rownames(simptmin)
simptmin$Estimate <- ifelse(simptmin$parameter=="cc", simptmin$Estimate, simptmin$Estimate + simptmin$Estimate[simptmin$parameter=="cc"])
simptmin <- round(mean(simptmin$Estimate), digits=2)
load("fssimpmodlong.Rdata")
simpfs <- as.data.frame(fixef(fssimplong.mod, pars=c("cc", "cc:speciesALNGLU", "cc:speciesBETPEN", "cc:speciesFAGSYL", "cc:speciesFRAEXC", "cc:speciesQUEROB")))
load("fssimpmod_long.Rdata")
simpfs <- as.data.frame(fixef(fssimplong.mod, pars=c("cc", "cc:speciesALNGLU", "cc:speciesBETPEN", "cc:speciesFAGSYL", "cc:speciesFRAEXC", "cc:speciesQUEROB")))
load("fstotmod_long.Rdata")
load("fstotmodlong.Rdata")
simpfs <- as.data.frame(fixef(fssimplong.mod, pars=c("cc", "cc:speciesALNGLU", "cc:speciesBETPEN", "cc:speciesFAGSYL", "cc:speciesFRAEXC", "cc:speciesQUEROB")))
simpfs <- as.data.frame(fixef(fstotlong.mod, pars=c("cc", "cc:speciesALNGLU", "cc:speciesBETPEN", "cc:speciesFAGSYL", "cc:speciesFRAEXC", "cc:speciesQUEROB")))
simpfs$parameter <- rownames(simpfs)
simpfs$Estimate <- ifelse(simpfs$parameter=="cc", simpfs$Estimate, simpfs$Estimate + simpfs$Estimate[simpfs$parameter=="cc"])
simpfs <- round(mean(simpfs$Estimate), digits=2)
aesccz <- round((mean(fixef(long.full, pars="cc.z", summary=FALSE))), digits=2)
alnccz <- round((mean(fixef(long.full, pars="cc.z", summary=FALSE))+mean(fixef(long.full, pars="cc.z:speciesALNGLU", summary=FALSE))), digits=2)
betccz <- round((mean(fixef(long.full, pars="cc.z", summary=FALSE))+mean(fixef(long.full, pars="cc.z:speciesBETPEN", summary=FALSE))), digits=2)
fagccz <- round((mean(fixef(long.full, pars="cc.z", summary=FALSE))+mean(fixef(long.full, pars="cc.z:speciesFAGSYL", summary=FALSE))), digits=3)
fraccz <- round((mean(fixef(long.full, pars="cc.z", summary=FALSE))+mean(fixef(long.full, pars="cc.z:speciesFRAEXC", summary=FALSE))), digits=2)
queccz <- round((mean(fixef(long.full, pars="cc.z", summary=FALSE))+mean(fixef(long.full, pars="cc.z:speciesQUEROB", summary=FALSE))), digits=2)
allccstand <- (aesccz+alnccz+betccz+fagccz+fraccz+queccz)/6   #0.16
### Okay now, we can calculate the interaction effects:
naocc<-round((mean(fixef(long.full, pars="nao.z", summary=FALSE)+mean(fixef(long.full, pars="nao.z:cc.z", summary=FALSE)))/4)/(sd(fs$nao)*2)*100*0.3, digits=2)
matcc<-round((mean(fixef(long.full, pars="mat.z", summary=FALSE)+mean(fixef(long.full, pars="mat.z:cc.z", summary=FALSE)))/4)/(sd(fs$mat)*2)*100*2, digits=2)
distcc<-round((mean(fixef(long.full, pars="dist.z", summary=FALSE)+mean(fixef(long.full, pars="dist.z:cc.z", summary=FALSE)))/4)/(sd(fs$distkm)*2)*100*150, digits=2)
elevcc<-round((mean(fixef(long.full, pars="elev.z", summary=FALSE)+mean(fixef(long.full, pars="elev.z:cc.z", summary=FALSE)))/4)/(sd(fs$elev)*2)*100*200, digits=2)
### Same rule but for DVR:
matdvr<-round((mean(fixef(dvrlong.full, pars="mat.z", summary=FALSE))/4)/(sd(fsdvr$mst)*2)*100*2, digits=2) ## -8.078
naodvr<-round((mean(fixef(dvrlong.full, pars="nao.z", summary=FALSE))/4)/(sd(fsdvr$nao)*2)*100*0.3, digits=2)## 2.04
distdvr<-round((mean(fixef(dvrlong.full, pars="dist.z", summary=FALSE))/4)/(sd(fsdvr$distkm)*2)*100*150, digits=2) ## 5.36
elevdvr<-round((mean(fixef(dvrlong.full, pars="elev.z", summary=FALSE))/4)/(sd(fsdvr$elev)*2)*100*200, digits=2) ## 1.77
ccdvr<-round((mean(fixef(dvrlong.full, pars="cc.z", summary=FALSE))/4)/(sd(fsdvr$cc)*2)*100, digits=2) ## 8.6
### Okay now, we can calculate the interaction effects:
naoccdvr<-round((mean(fixef(dvrlong.full, pars="nao.z", summary=FALSE)+mean(fixef(dvrlong.full, pars="nao.z:cc.z", summary=FALSE)))/4)/(sd(fsdvr$nao)*2)*100*0.3, digits=2)
matccdvr<-round((mean(fixef(dvrlong.full, pars="mat.z", summary=FALSE)+mean(fixef(dvrlong.full, pars="mat.z:cc.z", summary=FALSE)))/4)/(sd(fsdvr$mat)*2)*100*2, digits=2)
distccdvr<-round((mean(fixef(dvrlong.full, pars="dist.z", summary=FALSE)+mean(fixef(dvrlong.full, pars="dist.z:cc.z", summary=FALSE)))/4)/(sd(fsdvr$distkm)*2)*100*150, digits=2)
elevccdvr<-round((mean(fixef(dvrlong.full, pars="elev.z", summary=FALSE)+mean(fixef(dvrlong.full, pars="elev.z:cc.z", summary=FALSE)))/4)/(sd(fsdvr$elev)*2)*100*200, digits=2)
### Same rule but for Five model:
matfivelong<-round((mean(fixef(fivelong.full, pars="mat.z", summary=FALSE))/4)/(sd(fsfivelong$mst)*2)*100*2, digits=2) ## -11.56
naofivelong<-round((mean(fixef(fivelong.full, pars="nao.z", summary=FALSE))/4)/(sd(fsfivelong$nao)*2)*100*0.3, digits=2) ## 1.26
distfivelong<-round((mean(fixef(fivelong.full, pars="dist.z", summary=FALSE))/4)/(sd(fsfivelong$distkm)*2)*100*150, digits=2) ## 2.75
### Same rule but for Five model:
matfivelong<-round((mean(fixef(fivelong.full, pars="mat.z", summary=FALSE))/4)/(sd(fsfive$mst)*2)*100*2, digits=2) ## -11.56
naofivelong<-round((mean(fixef(fivelong.full, pars="nao.z", summary=FALSE))/4)/(sd(fsfive$nao)*2)*100*0.3, digits=2) ## 1.26
distfivelong<-round((mean(fixef(fivelong.full, pars="dist.z", summary=FALSE))/4)/(sd(fsfive$distkm)*2)*100*150, digits=2) ## 2.75
elevfivelong<-round((mean(fixef(fivelong.full, pars="elev.z", summary=FALSE))/4)/(sd(fsfive$elev)*2)*100*200, digits=2) ## 7.35
ccfivelong<-round((mean(fixef(fivelong.full, pars="cc.z", summary=FALSE))/4)/(sd(fsfive$cc)*2)*100, digits=2) ## 14.55
allfivelongccstand<-((mean(fixef(fivelong.full, pars="cc.z", summary=FALSE)))+(mean(fixef(fivelong.full, pars="cc.z", summary=FALSE))+mean(fixef(fivelong.full, pars="speciesALNGLU", summary=FALSE)))+(mean(fixef(fivelong.full, pars="cc.z", summary=FALSE))+mean(fixef(fivelong.full, pars="speciesBETPEN", summary=FALSE)))+(mean(fixef(fivelong.full, pars="cc.z", summary=FALSE))+mean(fixef(fivelong.full, pars="speciesFAGSYL", summary=FALSE)))+(mean(fixef(fivelong.full, pars="cc.z", summary=FALSE))+mean(fixef(fivelong.full, pars="speciesFRAEXC", summary=FALSE)))+(mean(fixef(fivelong.full, pars="cc.z", summary=FALSE))+mean(fixef(fivelong.full, pars="QUEROB", summary=FALSE))))/6
allfivelongcc<-round((allfivelongccstand/4)/(sd(fsfive$cc)*2)*100, digits=2)
allfivelongccstand<-((mean(fixef(fivelong.full, pars="cc.z", summary=FALSE)))+(mean(fixef(fivelong.full, pars="cc.z", summary=FALSE))+mean(fixef(fivelong.full, pars="speciesALNGLU", summary=FALSE)))+(mean(fixef(fivelong.full, pars="cc.z", summary=FALSE))+mean(fixef(fivelong.full, pars="speciesBETPEN", summary=FALSE)))+(mean(fixef(fivelong.full, pars="cc.z", summary=FALSE))+mean(fixef(fivelong.full, pars="speciesFAGSYL", summary=FALSE)))+(mean(fixef(fivelong.full, pars="cc.z", summary=FALSE))+mean(fixef(fivelong.full, pars="speciesFRAEXC", summary=FALSE)))+(mean(fixef(fivelong.full, pars="cc.z", summary=FALSE))+mean(fixef(fivelong.full, pars="speciesQUEROB", summary=FALSE))))/6
allfivelongcc<-round((allfivelongccstand/4)/(sd(fsfive$cc)*2)*100, digits=2)
### Okay now, we can calculate the interaction effects:
naoccfivelong<-round((mean(fixef(fivelong.full, pars="nao.z", summary=FALSE)+mean(fixef(fivelong.full, pars="nao.z:cc.z", summary=FALSE)))/4)/(sd(fsfive$nao)*2)*100*0.3, digits=2)
matccfivelong<-round((mean(fixef(fivelong.full, pars="mat.z", summary=FALSE)+mean(fixef(fivelong.full, pars="mat.z:cc.z", summary=FALSE)))/4)/(sd(fsfive$mat)*2)*100*2, digits=2)
distccfivelong<-round((mean(fixef(fivelong.full, pars="dist.z", summary=FALSE)+mean(fixef(fivelong.full, pars="dist.z:cc.z", summary=FALSE)))/4)/(sd(fsfive$distkm)*2)*100*150, digits=2)
elevccfivelong<-round((mean(fixef(fivelong.full, pars="elev.z", summary=FALSE)+mean(fixef(fivelong.full, pars="elev.z:cc.z", summary=FALSE)))/4)/(sd(fsfive$elev)*2)*100*200, digits=2)
### Lastly, we calculate the longtemps model
matlongtemps<-round((mean(fixef(longtemps.full, pars="mat.z", summary=FALSE))/4)/(sd(fslongtemps$mst)*2)*100*2, digits=2) ## -11.56
alllongtempsccstand<-((mean(fixef(longtemps.full, pars="cc.z", summary=FALSE)))+(mean(fixef(longtemps.full, pars="cc.z", summary=FALSE))+mean(fixef(longtemps.full, pars="speciesALNGLU", summary=FALSE)))+(mean(fixef(longtemps.full, pars="cc.z", summary=FALSE))+mean(fixef(longtemps.full, pars="speciesBETPEN", summary=FALSE)))+(mean(fixef(longtemps.full, pars="cc.z", summary=FALSE))+mean(fixef(longtemps.full, pars="speciesFAGSYL", summary=FALSE)))+(mean(fixef(longtemps.full, pars="cc.z", summary=FALSE))+mean(fixef(longtemps.full, pars="speciesFRAEXC", summary=FALSE)))+(mean(fixef(longtemps.full, pars="cc.z", summary=FALSE))+mean(fixef(longtemps.full, pars="speciesQUEROB", summary=FALSE))))/6
alllongtempscc<-round((alllongtempsccstand/4)/(sd(fstemps$cc)*2)*100, digits=2)
### And now for the interaction effects
naocclongtemps<-round((mean(fixef(longtemps.full, pars="nao.z", summary=FALSE)+mean(fixef(longtemps.full, pars="nao.z:cc.z", summary=FALSE)))/4)/(sd(fstemps$nao)*2)*100*0.3, digits=2)
matcclongtemps<-round((mean(fixef(longtemps.full, pars="mat.z", summary=FALSE)+mean(fixef(longtemps.full, pars="mat.z:cc.z", summary=FALSE)))/4)/(sd(fstemps$mat)*2)*100*2, digits=2)
distcclongtemps<-round((mean(fixef(longtemps.full, pars="dist.z", summary=FALSE)+mean(fixef(longtemps.full, pars="dist.z:cc.z", summary=FALSE)))/4)/(sd(fstemps$distkm)*2)*100*150, digits=2)
elevcclongtemps<-round((mean(fixef(longtemps.full, pars="elev.z", summary=FALSE)+mean(fixef(longtemps.full, pars="elev.z:cc.z", summary=FALSE)))/4)/(sd(fstemps$elev)*2)*100*200, digits=2)
## housekeeping
rm(list=ls())
