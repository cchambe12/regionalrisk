if(length(row.names) != gob$np)
stop("row.names wrong length")
if (length(unique(row.names)) != length(row.names))
stop("non-unique row.names given")
}
if (gob$np < 1) stop("non-positive gob$np")
if (is.null(row.names)) row.names <- as.character(1:gob$np)
if(sym){
for (i in 1:gob$np) {
res[[i]] <- sort(unique(c(gob$to[gob$from==i],
gob$from[gob$to==i])))
if(length(res[[i]]) == 0L) res[[i]] <- 0L
}
}
else{
for (i in 1:gob$np) {
res[[i]] <- sort(gob$to[gob$from==i])
if(length(res[[i]]) == 0L) res[[i]] <- 0L
}
}
attr(res, "region.id") <- row.names
attr(res, "call") <- attr(gob, "call")
attr(res, "type") <- attr(gob, "type")
class(res) <- "nb"
res <- sym.attr.nb(res)
res
}
bc<-bcoords[sample(nrow(bcoords), 100, replace=FALSE)]
bc<-bcoords[sample(nrow(bcoords), 100, replace=FALSE),]
nb<-graph2nb(gabrielneigh(as.matrix(bc)), sym=TRUE)
listw<-nb2listw(nb, style ="B")
y<-as.vector(bprep$y)
MEM.moransel <- function (y, listw, MEM.autocor = c("positive", "negative", "all"),
nperm = 999, alpha = 0.0001) {
SPATIAL = "FALSE"
# number of regions:
nb_sites <- length(y)
MEM.autocor <- match.arg(MEM.autocor)
MEM <- scores.listw(listw, MEM.autocor = MEM.autocor)
I.test <- function (y, listw, nperm, MEM.autocor, alpha) {
# The function I.test() tests the significance of the Moran's I of 'y' by 'nperm'
# permutations. If 'MEM.autocor' = 'all', two p-values are computed to test
# whether the observed Moran's I is greater or smaller than expected by chance,
# respectively. The p-values are then corrected by the Sidak correction for multiple
# tests to control the type I error rate.
# The function returns "TRUE" if at least one (corrected) p-value is <= 'alpha', and
# "FALSE" otherwise.
if (MEM.autocor == "all")
alter <- c("greater", "less")
else {
if (MEM.autocor == "positive")
alter <- "greater"
else alter <- "less"
}
p <- sapply(alter, function (x) moran.mc(y, listw, nperm, alternative = x)$p.value)
# Correction of both p-values with the Sidak correction if 'MEM.autocor' = 'all':
if (MEM.autocor == "all") p <- 1-(1-p)^2
if (length(which(p <= alpha)) == 0)
signif <- FALSE
else signif <- TRUE
return(signif)
}
I <- I.test(y, listw, nperm, MEM.autocor, alpha)
if (I == TRUE) {
SPATIAL <- "TRUE"
MEM.sel <- data.frame(row.names = row.names(MEM))
}
nbloop <- c()
while (I == TRUE) {
nbloop <- c(nbloop, 1)                   # Loop counter
I.vector <- vector("numeric", ncol(MEM)) # For the I computed with each MEM variable
for (i in 1:ncol(MEM)) {
mod <- lm(y ~ MEM[, i])
I.vector[i] <- moran(residuals(mod), listw, nb_sites, Szero(listw))$I
}
min.moran <- which.min(abs(I.vector))
# Selection of the MEM variable(s) best minimizing the Moran's I value of the residuals:
MEM.sel[, sum(nbloop)] <- MEM[, min.moran]
colnames(MEM.sel)[sum(nbloop)] <- colnames(MEM)[min.moran]
y <- residuals(lm(y ~ MEM.sel[, sum(nbloop)]))
I <- I.test(y, listw, nperm, MEM.autocor, alpha)
}
if (SPATIAL == "FALSE") return("No significant spatial structure")
else list(MEM.all = MEM, MEM.select = MEM.sel)
# By David Bauman; davbauman@gmail.com
}
moransel<-MEM.moransel(y, listw, MEM.autocor=MEM_model, nperm=999, alpha=0.001)
## housekeeping
rm(list=ls())
options(stringsAsFactors = FALSE)
# Load Libraries
library(tidyr)
library(spdep)
library(adespatial)
bb<-read.csv("/n/wolkovich_lab/Lab/Cat/fs_yearsitespp.csv", header=TRUE)
bb$lat.long<-paste(bb$lat, bb$long)
bb<-read.csv("~/Documents/git/regionalrisk/analyses/output/fs_yearsitespp.csv", header=TRUE)
bb$lat.long<-paste(bb$lat, bb$long)
bb<-subset(bb, select=c("long", "lat", "year", "fs.count", "lat.long"))
bb<-bb[!duplicated(bb),]
bb$fs.num<-ave(bb$fs.count, bb$lat.long, FUN=sum)
bprep<-subset(bb, select=c("fs.num", "lat.long"))
bprep<-bprep[!duplicated(bprep),]
bprep<-bprep[sample(nrow(bprep), 100, replace=FALSE),]
bprep$y<-bprep$fs.num
bprep<-subset(bprep, select=c("lat.long", "y"))
bprep<-bprep[!duplicated(bprep),]
bcoord<-subset(bprep, select="lat.long")
bcoords<-as.data.frame(bcoord[!duplicated(bcoord),])
bcoords<-tidyr::separate(data = bcoords, col = 1, into = c("lat", "long"), sep = "\\ ")
bcoords$lat<-as.numeric(bcoords$lat)
bcoords$long<-as.numeric(bcoords$long)
MEM_model <-"positive"
bcoords<-as.matrix(bcoords)
graph2nb <- function(gob, row.names=NULL,sym=FALSE) {
if (!inherits(gob, "Graph")) stop("Not a Graph object")
res <- vector(mode="list", length=gob$np)
if (!is.null(row.names)) {
if(length(row.names) != gob$np)
stop("row.names wrong length")
if (length(unique(row.names)) != length(row.names))
stop("non-unique row.names given")
}
if (gob$np < 1) stop("non-positive gob$np")
if (is.null(row.names)) row.names <- as.character(1:gob$np)
if(sym){
for (i in 1:gob$np) {
res[[i]] <- sort(unique(c(gob$to[gob$from==i],
gob$from[gob$to==i])))
if(length(res[[i]]) == 0L) res[[i]] <- 0L
}
}
else{
for (i in 1:gob$np) {
res[[i]] <- sort(gob$to[gob$from==i])
if(length(res[[i]]) == 0L) res[[i]] <- 0L
}
}
attr(res, "region.id") <- row.names
attr(res, "call") <- attr(gob, "call")
attr(res, "type") <- attr(gob, "type")
class(res) <- "nb"
res <- sym.attr.nb(res)
res
}
#bc<-bcoords[sample(nrow(bcoords), 100, replace=FALSE),]
nb<-graph2nb(gabrielneigh(as.matrix(bcoords)), sym=TRUE)
listw<-nb2listw(nb, style ="B")
y<-as.vector(bprep$y)
MEM.moransel <- function (y, listw, MEM.autocor = c("positive", "negative", "all"),
nperm = 999, alpha = 0.0001) {
SPATIAL = "FALSE"
# number of regions:
nb_sites <- length(y)
MEM.autocor <- match.arg(MEM.autocor)
MEM <- scores.listw(listw, MEM.autocor = MEM.autocor)
I.test <- function (y, listw, nperm, MEM.autocor, alpha) {
# The function I.test() tests the significance of the Moran's I of 'y' by 'nperm'
# permutations. If 'MEM.autocor' = 'all', two p-values are computed to test
# whether the observed Moran's I is greater or smaller than expected by chance,
# respectively. The p-values are then corrected by the Sidak correction for multiple
# tests to control the type I error rate.
# The function returns "TRUE" if at least one (corrected) p-value is <= 'alpha', and
# "FALSE" otherwise.
if (MEM.autocor == "all")
alter <- c("greater", "less")
else {
if (MEM.autocor == "positive")
alter <- "greater"
else alter <- "less"
}
p <- sapply(alter, function (x) moran.mc(y, listw, nperm, alternative = x)$p.value)
# Correction of both p-values with the Sidak correction if 'MEM.autocor' = 'all':
if (MEM.autocor == "all") p <- 1-(1-p)^2
if (length(which(p <= alpha)) == 0)
signif <- FALSE
else signif <- TRUE
return(signif)
}
I <- I.test(y, listw, nperm, MEM.autocor, alpha)
if (I == TRUE) {
SPATIAL <- "TRUE"
MEM.sel <- data.frame(row.names = row.names(MEM))
}
nbloop <- c()
while (I == TRUE) {
nbloop <- c(nbloop, 1)                   # Loop counter
I.vector <- vector("numeric", ncol(MEM)) # For the I computed with each MEM variable
for (i in 1:ncol(MEM)) {
mod <- lm(y ~ MEM[, i])
I.vector[i] <- moran(residuals(mod), listw, nb_sites, Szero(listw))$I
}
min.moran <- which.min(abs(I.vector))
# Selection of the MEM variable(s) best minimizing the Moran's I value of the residuals:
MEM.sel[, sum(nbloop)] <- MEM[, min.moran]
colnames(MEM.sel)[sum(nbloop)] <- colnames(MEM)[min.moran]
y <- residuals(lm(y ~ MEM.sel[, sum(nbloop)]))
I <- I.test(y, listw, nperm, MEM.autocor, alpha)
}
if (SPATIAL == "FALSE") return("No significant spatial structure")
else list(MEM.all = MEM, MEM.select = MEM.sel)
# By David Bauman; davbauman@gmail.com
}
moransel<-MEM.moransel(y, listw, MEM.autocor=MEM_model, nperm=999, alpha=0.001)
dselect<-as.data.frame(moransel[["MEM.select"]])
moransel
### Looking at Lat Model in Odyssey
library(rstanarm)
library(brms)
library(rstan)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
lat.stan<-read.csv("~/Documents/git/ospree/analyses/lat_analysis/lat_output/lat_arm.csv", header=TRUE)
lat.stan<-subset(lat.stan, lat.stan$resp<600)
lat.cen <- brm(resp ~ (force.z + photo.z + chill.z + lat.z +
force.z:photo.z + force.z:chill.z + photo.z:chill.z + force.z:lat.z +
photo.z:lat.z + chill.z:lat.z)+
((force.z + photo.z + chill.z + lat.z +
force.z:photo.z + force.z:chill.z + photo.z:chill.z + force.z:lat.z +
photo.z:lat.z + chill.z:lat.z)|complex), data = lat.stan,
chains = 4, cores = 4,control = list(max_treedepth = 12,adapt_delta = 0.99))
install.packages(c("brms", "Rcpp", "rstan"))
rm(list=ls())
options(stringsAsFactors = FALSE)
library(adespatial)
library(vegan)
library(spdep)
bb<-read.csv("~/Documents/git/regionalrisk/analyses/output/regrisk.nov.csv", header=TRUE)
MEM_model<-"positive"
style<-"B"
C<-subset(bb, select=c(long, lat))
C<-C[sample(nrow(C), 70, replace=FALSE),]
C$xy<-paste(C$long, C$lat)
C<-C[!duplicated(C$xy),]
C<-subset(C, select=c(long, lat))
nb<-graph2nb(gabrielneigh(as.matrix(C), nnmult=5), sym=TRUE)
listw<- nb2listw(nb, style=style)
MEM<-scores.listw(listw, MEM.autocor = MEM_model)
bb$Y<-ave(bb$fs.count, bb$lat.long, FUN=sum)
bbs<-bb[!duplicated(bb$lat.long),]
Y<-bbs$Y
X<-subset(bbs, select=c(elev, distkm, mst))
source("scripts/MEM.moransel.R")
source("~/Documents/git/regionalrisk/analyses/scripts/MEM.moransel.R")
moransel<-MEM.moransel(Y, listw, MEM.autocor=MEM_model, nperm=999, alpha=0.001)
require(spdep)
require(adespatial)
require(vegan)
rm(list=ls())
options(stringsAsFactors = FALSE)
## Libraries
library(rstan)
library(brms)
bb<-read.csv("~/Documents/git/regionalrisk/analyses/output/bb_latprep_nov.csv", header=TRUE)
bb$fs<-ifelse(bb$fs.count>0, 1, 0)
bb$nao.z <- (bb$nao-mean(bb$nao,na.rm=TRUE))/(2*sd(bb$nao,na.rm=TRUE))
bb$mat.z <- (bb$mst-mean(bb$mst,na.rm=TRUE))/(2*sd(bb$mst,na.rm=TRUE))
bb$cc.z <- (bb$cc-mean(bb$cc,na.rm=TRUE))/(2*sd(bb$cc,na.rm=TRUE))
bb$elev.z <- (bb$elev-mean(bb$elev,na.rm=TRUE))/(2*sd(bb$elev,na.rm=TRUE))
bb$lat.z <- (bb$lat-mean(bb$lat,na.rm=TRUE))/(2*sd(bb$lat,na.rm=TRUE))
bb$dist.z <-(bb$distkm-mean(bb$distkm,na.rm=TRUE))/(2*sd(bb$distkm,na.rm=TRUE))
bb$space.z <-(bb$space-mean(bb$space,na.rm=TRUE))/(2*sd(bb$space,na.rm=TRUE))
bb<-bb[sample(nrow(bb), 1000), ]
mod.nb<-brm(fs ~ nao.z + mat.z + dist.z + space.z + elev.z +
cc.z + species + nao.z:species +
mat.z:species + dist.z:species + space.z:species + elev.z:species + cc.z:species +
nao.z:cc.z + mat.z:cc.z + dist.z:cc.z + space.z:cc.z + elev.z:cc.z, data=bb, #cores=4,
family=zero_one_inflated_beta())
library(spdep)
library(adespatial)
bb<-read.csv("~/Documents/git")
bb<-read.csv("~/Documents/git/regionalrisk/analyses/output/regrisk.nov.csv", header=TRUE)
bb<-bb[sample(nrow(bb), 500), ]
MEM_model<-"positive"
style<-"B"
C<-subset(bb, select=c(long, lat))
C<-C[sample(nrow(C), 70, replace=FALSE),]
C$xy<-paste(C$long, C$lat)
C<-C[!duplicated(C$xy),]
C<-subset(C, select=c(long, lat))
nb<-graph2nb(gabrielneigh(as.matrix(C), nnmult=5), sym=TRUE)
listw<- nb2listw(nb, style=style)
MEM<-scores.listw(listw, MEM.autocor = MEM_model)
bb$Y<-ave(bb$fs.count, bb$lat.long, FUN=sum)
bbs<-bb[!duplicated(bb$lat.long),]
Y<-bbs$Y
X<-subset(bbs, select=c(elev, distkm, mst))
source("MEM.moransel.R")
source("~/Documents/git/regionalrisk/analyses/scripts/source/MEM.moransel.R")
source("~/Documents/git/regrisk/analyses/scripts/source/MEM.moransel.R")
source("~/Documents/git/regionalrisk/analyses/scripts/MEM.moransel.R")
moransel<-MEM.moransel(Y, listw, MEM.autocor=MEM_model, nperm=999, alpha=0.001)
bb<-read.csv("~/Documents/git/regionalrisk/analyses/output/regrisk.nov.csv", header=TRUE)
bb<-bb[sample(nrow(bb), 500), ]
MEM_model<-"positive"
style<-"B"
C<-subset(bb, select=c(long, lat))
C$xy<-paste(C$long, C$lat)
C<-C[!duplicated(C$xy),]
C<-subset(C, select=c(long, lat))
nb<-graph2nb(gabrielneigh(as.matrix(C), nnmult=5), sym=TRUE)
listw<- nb2listw(nb, style=style)
MEM<-scores.listw(listw, MEM.autocor = MEM_model)
bb$Y<-ave(bb$fs.count, bb$lat.long, FUN=sum)
bbs<-bb[!duplicated(bb$lat.long),]
Y<-bbs$Y
X<-subset(bbs, select=c(elev, distkm, mst))
source("MEM.moransel.R")
source("~/Documents/git/regionalrisk/analyses/scripts/MEM.moransel.R")
moransel<-MEM.moransel(Y, listw, MEM.autocor=MEM_model, nperm=999, alpha=0.001)
dselect<-as.data.frame(moransel[["MEM.select"]])
require(rstan)
library(rstan)
library(brms)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
bb<-read.csv("~/Documents/git/regionalrisk/analyses/output/bb_latprep_nov.csv", header=TRUE)
bb$fs<-ifelse(bb$fs.count>0, 1, 0)
bb$nao.z <- (bb$nao-mean(bb$nao,na.rm=TRUE))/(2*sd(bb$nao,na.rm=TRUE))
bb$mat.z <- (bb$mst-mean(bb$mst,na.rm=TRUE))/(2*sd(bb$mst,na.rm=TRUE))
bb$cc.z <- (bb$cc-mean(bb$cc,na.rm=TRUE))/(2*sd(bb$cc,na.rm=TRUE))
bb$elev.z <- (bb$elev-mean(bb$elev,na.rm=TRUE))/(2*sd(bb$elev,na.rm=TRUE))
bb$lat.z <- (bb$lat-mean(bb$lat,na.rm=TRUE))/(2*sd(bb$lat,na.rm=TRUE))
bb$dist.z <-(bb$distkm-mean(bb$distkm,na.rm=TRUE))/(2*sd(bb$distkm,na.rm=TRUE))
bb$space.z <-(bb$space-mean(bb$space,na.rm=TRUE))/(2*sd(bb$space,na.rm=TRUE))
bb<-bb[sample(nrow(bb), 1000), ]
brm
base.test<-brm(fs ~ nao.z + mat.z + dist.z + space.z + elev.z +
cc.z + species + nao.z:species +
mat.z:species + dist.z:species + space.z:species + elev.z:species + cc.z:species +
nao.z:cc.z + mat.z:cc.z + dist.z:cc.z + space.z:cc.z + elev.z:cc.z, data=bb)
base.test
pp_check(base.test)
mod.nb<-brm(fs ~ nao.z + mat.z + dist.z + space.z + elev.z +
cc.z + species + nao.z:species +
mat.z:species + dist.z:species + space.z:species + elev.z:species + cc.z:species +
nao.z:cc.z + mat.z:cc.z + dist.z:cc.z + space.z:cc.z + elev.z:cc.z, data=bb, cores=4,
family=zero_one_inflated_beta())
no.space<-brm(fs ~ nao.z + mat.z + dist.z + space.z + elev.z +
cc.z + species + nao.z:species +
mat.z:species + dist.z:species + elev.z:species + cc.z:species +
nao.z:cc.z + mat.z:cc.z + dist.z:cc.z + elev.z:cc.z, data=bb, chains=2,
family=zero_one_inflated_beta())
library(adespatial)
library(spdep)
library(vegan)
bb<-read.csv("~/Documents/git/regionalrisk/analyses/output/regrisk.nov.csv", header=TRUE)
bb<-bb[sample(nrow(bb), 5000, replace=FALSE),]
MEM_model<-"positive"
style<-"B"
C<-subset(bb, select=c(long, lat))
C$xy<-paste(C$long, C$lat)
C<-C[!duplicated(C$xy),]
C<-subset(C, select=c(long, lat))
nb<-graph2nb(gabrielneigh(as.matrix(C), nnmult=5), sym=TRUE)
listw<- nb2listw(nb, style=style)
MEM<-scores.listw(listw, MEM.autocor = MEM_model)
bb$Y<-ave(bb$fs.count, bb$lat.long, FUN=sum)
bbs<-bb[!duplicated(bb$lat.long),]
Y<-bbs$Y
X<-subset(bbs, select=c(elev, distkm, mst))
source("MEM.moransel.R")
source("~/Documents/git/regionalrisk/analyses/scripts/MEM.moransel.R")
moransel<-MEM.moransel(Y, listw, MEM.autocor=MEM_model, nperm=999, alpha=0.001)
bb<-read.csv("~/Documents/git/regionalrisk/analyses/output/regrisk.nov.csv", header=TRUE)
bb<-bb[sample(nrow(bb), 100, replace=FALSE),]
MEM_model<-"positive"
style<-"B"
C<-subset(bb, select=c(long, lat))
C$xy<-paste(C$long, C$lat)
C<-C[!duplicated(C$xy),]
C<-subset(C, select=c(long, lat))
nb <- graph2nb(gabrielneigh(as.matrix(C), nnmult=5), sym=TRUE)
listw <- nb2listw(nb, style=style)
MEM <- scores.listw(listw, MEM.autocor = MEM_model)
bb$Y<-ave(bb$fs.count, bb$lat.long, FUN=sum)
bbs<-bb[!duplicated(bb$lat.long),]
Y<-bbs$Y
Y <- decostand(Y, method = "hellinger")
C <- as.matrix(C)
X<-subset(bbs, select=c(elev, distkm, mst))
source("MEM.moransel.R")
source("~/Documents/git/regionalrisk/analyses/scripts/MEM.moransel.R")
moransel<-MEM.moransel(Y, C, listw, MEM.autocor=MEM_model, nperm=999, alpha=0.001)
moransel<-MEM.moransel(Y, listw, MEM.autocor = MEM_model, nperm=999, alpha=0.05)
bb<-read.csv("~/Documents/git/regionalrisk/analyses/output/regrisk.nov.csv", header=TRUE)
bb<-bb[sample(nrow(bb), 500, replace=FALSE),]
MEM_model<-"positive"
style<-"B"
C<-subset(bb, select=c(long, lat))
C$xy<-paste(C$long, C$lat)
C<-C[!duplicated(C$xy),]
C<-subset(C, select=c(long, lat))
nb <- graph2nb(gabrielneigh(as.matrix(C), nnmult=5), sym=TRUE)
listw <- nb2listw(nb, style=style)
MEM <- scores.listw(listw, MEM.autocor = MEM_model)
bb$Y<-ave(bb$fs.count, bb$lat.long, FUN=sum)
bbs<-bb[!duplicated(bb$lat.long),]
Y<-bbs$Y
Y <- decostand(Y, method = "hellinger")
C <- as.matrix(C)
X<-subset(bbs, select=c(elev, distkm, mst))
source("~/Documents/git/regionalrisk/analyses/scripts/MEM.moransel.R")
moransel<-MEM.moransel(Y, listw, MEM.autocor = MEM_model, nperm=999, alpha=0.05)
load("/Users/CatherineChamberlain/Documents/git/regionalrisk/elevdist_base.Rdata")
base.test
pp_check(base.test)
library(rstanarm)
pp_check(base.test)
launch_shinystan(base.test)
(loo1 <- loo(base.test))
# perform 10-fold cross validation
kfold1 <- kfold(base.test, chains = 1)
# perform 10-fold cross validation
kfold1 <- kfold(base.test)
# perform 10-fold cross validation
kfold1 <- brms::kfold(base.test, chains=1)
install.packages(c("rgdal", "rstan"))
# perform 10-fold cross validation
kfold1 <- brms::kfold(base.test, chains=1)
temp_base.test <- update(base.test, chains = 0)
load("/Users/CatherineChamberlain/Desktop/Odyssey/Odyssey Models/elevdist_binom.Rdata")
binom
pp_check(binom)
(loo1 <- loo(binom))
# perform 10-fold cross validation
(kfold1 <- brms::kfold(binom, chains=1))
load("/Users/CatherineChamberlain/Desktop/Odyssey/Odyssey Models/elevdist_brms.Rdata")
mod.nb
pp_check(mod.nb)
(loo1 <- loo(mod.nb))
load("/Users/CatherineChamberlain/Desktop/Odyssey/Odyssey Models/elevdist_nospace.Rdata")
no.space
pp_check(no.space)
(loo1 <- loo(no.space))
load("/Users/CatherineChamberlain/Documents/git/regionalrisk/analyses/scripts/elevdist_pois.Rdata")
pois
(loo1 <- loo(pois))
library(brms)
pp_check(pois)
pois
pp_check(pois)
load("/Users/CatherineChamberlain/Desktop/Odyssey/Odyssey Models/elevdist_poisson.Rdata")
poisson
pp_check(poisson)
(loo1 <- loo(poisson))
load("/Users/CatherineChamberlain/Desktop/Odyssey/Odyssey Models/elevdist_hurdle.Rdata")
hurdle
(loo1 <- loo(hurdle))
library(brms)
(loo1 <- loo(hurdle))
(loo1 <- loo(hurdle))
(waic1 <- waic(hurdle))
load("/Users/CatherineChamberlain/Desktop/Odyssey/Odyssey Models/elevdist_base2chains.Rdata")
base
library(rstanarm)
pp_check(hurdle)
pp_check(base)
pp_check(base, type="xyz")
pp_check(base, type="stat")
pp_check(base, type="error_scatter")
pp_check(base, type="scatter")
pp_check(base, type="loo_intervals")
pp_check(base, stat=c("min", "max", "mean", "sd"))
pp_check.brmsfit(base, stat=c("min", "max", "mean", "sd"))
bayesplot::pp_check(base, stat=c("min", "max", "mean", "sd"))
bayesplot::pp_check(base, type=c("min", "max", "mean", "sd"))
bayesplot::pp_check(base, type="min")
bayesplot::pp_check(base, type="stat_grouped")
bayesplot::pp_check(base, type="stat_grouped", group="min")
bayesplot::pp_check(base, type="stat_grouped", group="species")
launch_shinystan(base,
rstudio = getOption("shinystan.rstudio"))
ppc_stat(base,  stat = "min")
library(bayesplot)
library(ggplot2)
ppc_stat(base,  stat = "min")
ppc_stat(fs,  stat = "min")
ppc_stat(y, y_rep,  stat = "min")
yrep_nb <- posterior_predict(base, draws = 500)
setwd("~/Documents/git/regionalrisk/analyses/output")
bb<-read.csv("bb_latprep_nov.csv", header=TRUE)
bb$fs<-ifelse(bb$fs.count>0, 1, 0)
bb$nao.z <- (bb$nao-mean(bb$nao,na.rm=TRUE))/(2*sd(bb$nao,na.rm=TRUE))
bb$mat.z <- (bb$mst-mean(bb$mst,na.rm=TRUE))/(2*sd(bb$mst,na.rm=TRUE))
bb$cc.z <- (bb$cc-mean(bb$cc,na.rm=TRUE))/(2*sd(bb$cc,na.rm=TRUE))
bb$elev.z <- (bb$elev-mean(bb$elev,na.rm=TRUE))/(2*sd(bb$elev,na.rm=TRUE))
bb$lat.z <- (bb$lat-mean(bb$lat,na.rm=TRUE))/(2*sd(bb$lat,na.rm=TRUE))
bb$dist.z <-(bb$distkm-mean(bb$distkm,na.rm=TRUE))/(2*sd(bb$distkm,na.rm=TRUE))
bb$space.z <-(bb$space-mean(bb$space,na.rm=TRUE))/(2*sd(bb$space,na.rm=TRUE))
y <- bb$fs
ppc_stat(y, yrep_nb,  stat = "min")
bb<-bb[sample(nrow(bb), 1000), ]
y <- bb$fs
ppc_stat(y, yrep_nb,  stat = "min")
ppc_stat(y, yrep_nb,  stat = "max")
ppc_stat(y, yrep_nb,  stat = "sd")
yrep_nb <- posterior_predict(hurdle, draws = 500)
load("/Users/CatherineChamberlain/Desktop/Odyssey/Odyssey Models/elevdist_binomial.Rdata")
(loo1 <- loo(binomial))
binomial
load("/Users/CatherineChamberlain/Desktop/Odyssey/Odyssey Models/elevdist_negbinom.Rdata")
negbinom
yrep_nb <- posterior_predict(negbinom, draws = 500)
y <- bb$fs
ppc_stat(y, yrep_nb,  stat = "sd")
load("/Users/CatherineChamberlain/Desktop/Odyssey/Odyssey Models/elevdist_hurdlepois.Rdata")
hurdpois
## Libraries
### 15 Oct 2018 - can't install brms, rstanarm or I think rstan properly
require(brms)
require(rstan)
